CSS 343  Regular Expression homework solutions        (Carol Zander, CSS 343)

Note that regular expressions and grammars are not unique.  Yours may look
very different from mine and still be correct.  Ask me if you're not sure.
These solutions use either '+' or '|' as the OR operator.

1.  Regular expressions -- Let the alphabet = {a,b}.  Note  e  is used for the
empty string.  Write regular expressions for:

  All words in which 'a' appears tripled (and only tripled, meaning all
  a's must appear in groups of three)(the empty string is valid).
         (aaa | b)*   

  All words that contain at least one of the strings s1, s2, s3, s4.
  (s1, s2, s3, s4 are variables representing some string of a's and b's.)
  For example, s1 could be "ab" or "abbaa" or "aaa" or "b" .
         (a | b)* (s1 | s2 | s3 | s4) (a | b)*
  Recall that  (a|b)*  generates any strings of a's and b's.  So there may
  be more occurrences of s1...s4, but they will be generated by the (a|b)*
  part of the regular expr.  Note that 
    (a|b)* (s1|s2|s3|s4) (a|b)* = (a|b)* (s1|s2|s3|s4) (s1|s2|s3|s4)* (a|b)*
  but the left side is more concise.

  All words that contain exactly three b's in total.
         a*ba*ba*ba*
  It will only generate three b's, but a's can be anywhere.

  All words that contain exactly two b's or exactly three b's.
         a*ba*ba* | a*ba*ba*ba*

  All strings that end in a double letter.
         (a | b)*aa | (a | b)*bb      or      (a | b)*(aa | bb)

  All strings that have exactly one double letter in them.
         (b | e)(ab)* aa (ba)* (b | e)   |   (a | e)(ba)* bb (ab)* (a | e)

  All strings that do not have the substring 'ab' .
         b*a*

2.  Write a regular expression for all unsigned numbers in Pascal.  They are
    strings such as 5280, 39.37, 499E3, 63.36E4, 1.894E-3, 2.3478E+11. 
    You are not allowed to have a naked decimal point.  For example the number
    5.  or  .5 is not allowed, must use 5.0 and 0.5.  The E is for exponent,
    essentially scientific notation.  

For ease in expressing, call the regular expression to generate one digit, d.
d = 0 | 1 | 2 | 3 | 4 | 5 | 6 | 7 | 8 | 9
Note that  e  is still the empty string.

dd* (e | .dd*) (e | E(+|-|e)dd*)

For these problems, the alphabet is {a,b}.
3.  Write reg expr for words with 'b' as the second letter.
      (a | b)b(a | b)*

4.  Write reg expr for words baa, ab, and abb .
      baa | ab | abb

5.  Write reg expr for only those words that have an even 
    number of letters total.
       ((a|b)(a|b))*

6.  Write reg expr for only those words that do not end in  "ba" .
      (a|b)*(aa|ab|bb) | a | b | e
    Beginning of the string can be anything, the (a|b)*, then
        force the last two letters to be anything, but "ba" .
        This gets them all except for strings with zero or one character.

7.  Let the alphabet be {0,1}.  Write a regular expression for
    the set of all strings not containing 101 as a substring.

    Attempt:  (00*0 | 100 | 11*1 | 001)* | 0 | 1 | 01 | 10 | 010 | ...
    still can't get 10010              _           _
                                     0| |        1| |                    ___
                                      | v         | v                   |   |
    Try finite state machine: start-> +a -------> +b -------> +c ----> trap |
                                       ^    1           0      |  1     ^   |
                                       |_______________________|        |___|
                                                  0                      0,1
    Since each state is final, create a part of a regular expression
    for each state.
                           state
      (0 | 11*00)*       //  a:  0 loop, then loop 11* to get to state b
                         //      and 00 to get back to state a

    | 0*11*(1*000*11*)*  //  b:  0*11* to get to state b, then loop 1*0
                         //      to get to state c and 00*11* back to b

    | 0*11*0(00*11*0)*   //  c:  0*11*0 to get to state c, then loop 0 
                         //      to get to state a and 0*11*0 back to c

